/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 *  [libhal] modifications to this file are as follows:
 *
 *    1. Remove macro SG14_USE_STD_ALIGNED_STORAGE and default to using the
 *       `aligned_storage_helper`.
 *    2. Replace SG14_INPLACE_FUNCTION_THROW with a direct call to `throw`.
 *    3. Convert header into module partition file.
 *    4. Modified class fields to use `m_` prefix to fix libhal style guide
 *    5. Applied clang-tidy modernization fixes
 *    6. Removed inplace_function_detail namespace since modules no longer leak
 *       internal details.
 *
 * Original Boost license is retained from the original source file.
 *
 * Link to original file:
 * https://github.com/Quuxplusone/SG14/blob/ee3de047e6b54975674caf5f9d6342489b7003d9/include/sg14/inplace_function.h
 */

module;

#include <cstddef>

#include <array>
#include <functional>
#include <type_traits>
#include <utility>

export module hal:inplace_function;

constexpr size_t inplace_function_default_capacity = 32;

template<size_t Cap>
union aligned_storage_helper
{
  struct double1
  {
    double a;
  };
  struct double4
  {
    std::array<double, 4> a;
  };
  template<class T>
  using maybe = std::conditional_t<(Cap >= sizeof(T)), T, char>;
  std::array<char, Cap> real_data;
  maybe<short> a;
  maybe<int> b;
  maybe<long> c;
  maybe<long long> d;
  maybe<void*> e;
  maybe<void (*)()> f;
  maybe<double1> g;
  maybe<double4> h;
  maybe<long double> i;
};

template<size_t Cap, size_t Align = alignof(aligned_storage_helper<Cap>)>
struct aligned_storage_t
{
  alignas(Align) std::array<char, Cap> data_;
};

static_assert(sizeof(aligned_storage_t<sizeof(void*)>) == sizeof(void*), "A");
static_assert(alignof(aligned_storage_t<sizeof(void*)>) == alignof(void*), "B");

template<class T>
struct wrapper
{
  using type = T;
};

template<class R, class... Args>
struct vtable
{
  using storage_ptr_t = void*;

  using invoke_ptr_t = R (*)(storage_ptr_t, Args&&...);
  using process_ptr_t = void (*)(storage_ptr_t, storage_ptr_t);
  using destructor_ptr_t = void (*)(storage_ptr_t);

  invoke_ptr_t const invoke_ptr;
  process_ptr_t const copy_ptr;
  process_ptr_t const relocate_ptr;
  destructor_ptr_t const destructor_ptr;

  // NOLINTNEXTLINE(bugprone-exception-escape)
  constexpr explicit vtable() noexcept
    : invoke_ptr(
        [](storage_ptr_t, Args&&...) -> R { throw std::bad_function_call(); })
    , copy_ptr([](storage_ptr_t, storage_ptr_t) {})
    , relocate_ptr([](storage_ptr_t, storage_ptr_t) {})
    , destructor_ptr([](storage_ptr_t) {})
  {
  }

  template<class C>
  constexpr explicit vtable(wrapper<C>) noexcept
    : invoke_ptr([](storage_ptr_t storage_ptr, Args&&... args) -> R {
      return (*static_cast<C*>(storage_ptr))(static_cast<Args&&>(args)...);
    })
    , copy_ptr([](storage_ptr_t dst_ptr, storage_ptr_t src_ptr) {
      ::new (dst_ptr) C{ (*static_cast<C*>(src_ptr)) };
    })
    , relocate_ptr([](storage_ptr_t dst_ptr, storage_ptr_t src_ptr) {
      ::new (dst_ptr) C{ std::move(*static_cast<C*>(src_ptr)) };
      static_cast<C*>(src_ptr)->~C();
    })
    , destructor_ptr(
        [](storage_ptr_t src_ptr) { static_cast<C*>(src_ptr)->~C(); })
  {
  }

  vtable(vtable const&) = delete;
  vtable(vtable&&) = delete;

  vtable& operator=(vtable const&) = delete;
  vtable& operator=(vtable&&) = delete;

  ~vtable() = default;
};

template<class R, class... Args>
#if __cplusplus >= 201703L
inline constexpr
#endif
  vtable<R, Args...>
    empty_vtable{};

template<size_t DstCap, size_t DstAlign, size_t SrcCap, size_t SrcAlign>
struct is_valid_inplace_dst : std::true_type
{
  static_assert(DstCap >= SrcCap,
                "Can't squeeze larger inplace_function into a smaller one");

  static_assert(DstAlign % SrcAlign == 0,
                "Incompatible inplace_function alignments");
};

// C++11 MSVC compatible implementation of std::is_invocable_r.

template<class R>
void accept(R);

template<class, class R, class F, class... Args>
struct is_invocable_r_impl : std::false_type
{};

template<class F, class... Args>
struct is_invocable_r_impl<decltype(std::declval<F>()(std::declval<Args>()...),
                                    void()),
                           void,
                           F,
                           Args...> : std::true_type
{};

template<class F, class... Args>
struct is_invocable_r_impl<decltype(std::declval<F>()(std::declval<Args>()...),
                                    void()),
                           void const,
                           F,
                           Args...> : std::true_type
{};

template<class R, class F, class... Args>
struct is_invocable_r_impl<decltype(accept<R>(
                             std::declval<F>()(std::declval<Args>()...))),
                           R,
                           F,
                           Args...> : std::true_type
{};

template<class R, class F, class... Args>
using is_invocable_r = is_invocable_r_impl<void, R, F, Args...>;

export namespace hal::sg14 {

template<class Signature,
         size_t Capacity = inplace_function_default_capacity,
         size_t Alignment = alignof(aligned_storage_t<Capacity>)>
class inplace_function;  // unspecified

template<class>
struct is_inplace_function : std::false_type
{};
template<class Sig, size_t Cap, size_t Align>
struct is_inplace_function<inplace_function<Sig, Cap, Align>> : std::true_type
{};
// Both one() and zero() will be visible.

template<class R, class... Args, size_t Capacity, size_t Alignment>
class inplace_function<R(Args...), Capacity, Alignment>
{
  using storage_t = ::aligned_storage_t<Capacity, Alignment>;
  using vtable_t = vtable<R, Args...>;
  using vtable_ptr_t = vtable_t const*;

  template<class, size_t, size_t>
  friend class inplace_function;

public:
  using capacity = std::integral_constant<size_t, Capacity>;
  using alignment = std::integral_constant<size_t, Alignment>;

  constexpr inplace_function() noexcept
    : m_vtable_ptr(std::addressof(empty_vtable<R, Args...>))
    , m_storage()
  {
  }

  template<class T,
           class C = std::decay_t<T>,
           class = std::enable_if_t<!is_inplace_function<C>::value &&
                                    is_invocable_r<R, C&, Args...>::value>>
  inplace_function(T&& closure)
  {
    static_assert(
      std::is_copy_constructible_v<C>,
      "inplace_function cannot be constructed from non-copyable type");

    static_assert(sizeof(C) <= Capacity,
                  "inplace_function cannot be constructed from object with "
                  "this (large) size");

    static_assert(Alignment % alignof(C) == 0,
                  "inplace_function cannot be constructed from object with "
                  "this (large) alignment");

    static vtable_t const vt(wrapper<C>{});
    m_vtable_ptr = std::addressof(vt);

    ::new (std::addressof(m_storage)) C(std::forward<T>(closure));
  }

  template<size_t Cap, size_t Align>
  inplace_function(inplace_function<R(Args...), Cap, Align> const& other)
    : inplace_function(other.vtable_ptr_,
                       other.vtable_ptr_->copy_ptr,
                       std::addressof(other.storage_))
  {
    static_assert(

      is_valid_inplace_dst<Capacity, Alignment, Cap, Align>::value,
      "conversion not allowed");
  }

  template<size_t Cap, size_t Align>
  inplace_function(inplace_function<R(Args...), Cap, Align>&& other) noexcept
    : inplace_function(other.vtable_ptr_,
                       other.vtable_ptr_->relocate_ptr,
                       std::addressof(other.storage_))
  {
    static_assert(

      is_valid_inplace_dst<Capacity, Alignment, Cap, Align>::value,
      "conversion not allowed");

    other.vtable_ptr_ = std::addressof(empty_vtable<R, Args...>);
  }

  inplace_function(std::nullptr_t) noexcept
    : m_vtable_ptr(std::addressof(empty_vtable<R, Args...>))
  {
  }

  inplace_function(inplace_function const& other)
    : m_vtable_ptr(other.m_vtable_ptr)
  {
    m_vtable_ptr->copy_ptr(std::addressof(m_storage),
                           std::addressof(other.m_storage));
  }

  inplace_function(inplace_function&& other) noexcept
    : m_vtable_ptr(std::exchange(other.m_vtable_ptr,
                                 std::addressof(empty_vtable<R, Args...>)))
  {
    m_vtable_ptr->relocate_ptr(std::addressof(m_storage),
                               std::addressof(other.m_storage));
  }

  inplace_function& operator=(std::nullptr_t) noexcept
  {
    m_vtable_ptr->destructor_ptr(std::addressof(m_storage));
    m_vtable_ptr = std::addressof(empty_vtable<R, Args...>);
    return *this;
  }

  inplace_function& operator=(inplace_function other) noexcept
  {
    m_vtable_ptr->destructor_ptr(std::addressof(m_storage));

    m_vtable_ptr = std::exchange(other.m_vtable_ptr,
                                 std::addressof(empty_vtable<R, Args...>));
    m_vtable_ptr->relocate_ptr(std::addressof(m_storage),
                               std::addressof(other.m_storage));
    return *this;
  }

  ~inplace_function()
  {
    m_vtable_ptr->destructor_ptr(std::addressof(m_storage));
  }

  R operator()(Args... args) const
  {
    return m_vtable_ptr->invoke_ptr(std::addressof(m_storage),
                                    std::forward<Args>(args)...);
  }

  constexpr bool operator==(std::nullptr_t) const noexcept
  {
    return !operator bool();
  }

  constexpr bool operator!=(std::nullptr_t) const noexcept
  {
    return operator bool();
  }

  constexpr explicit operator bool() const noexcept
  {
    return m_vtable_ptr != std::addressof(empty_vtable<R, Args...>);
  }

  void swap(inplace_function& other) noexcept
  {
    if (this == std::addressof(other))
      return;

    storage_t tmp;
    m_vtable_ptr->relocate_ptr(std::addressof(tmp), std::addressof(m_storage));

    other.m_vtable_ptr->relocate_ptr(std::addressof(m_storage),
                                     std::addressof(other.m_storage));

    m_vtable_ptr->relocate_ptr(std::addressof(other.m_storage),
                               std::addressof(tmp));

    std::swap(m_vtable_ptr, other.m_vtable_ptr);
  }

  friend void swap(inplace_function& lhs, inplace_function& rhs) noexcept
  {
    lhs.swap(rhs);
  }

private:
  vtable_ptr_t m_vtable_ptr;
  mutable storage_t m_storage;

  inplace_function(vtable_ptr_t vtable_ptr,
                   typename vtable_t::process_ptr_t process_ptr,
                   typename vtable_t::storage_ptr_t storage_ptr)
    : m_vtable_ptr(vtable_ptr)
  {
    process_ptr(std::addressof(m_storage), storage_ptr);
  }
};
}  // namespace hal::sg14
